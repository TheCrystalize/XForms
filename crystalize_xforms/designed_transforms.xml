<?xml version="1.0" encoding="utf-8"?>
<user_transforms>\n\n
	<transform_def name="designed_3rd">
		<node name="input_params">
			<real name="designed_3rd">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd_init_result(designed_3rd, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = exp(abs(cos(p_in.x)) + abs(sin(p_in.y)))
					b = sin(length(p_in) + exp(abs(p_in.x * halfinvpi())))
					c = fmod(b, a) * r
					s = mat2x2(cos(c), -sin(c),
											sin(c), cos(c)) * p_in
					z = fmod(atan2(s.y, abs(s.x)), atan2(s.x, abs(s.y))) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd01">
		<node name="input_params">
			<real name="designed_3rd01">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd01_init_result(designed_3rd01, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					z = tan(abs(p_in.x) + length(p_in) * (abs(sin(p_in.y / halfpi())) + abs(cos(p_in.x / halfpi()))) * (abs(cos(p_in.y / halfpi())) + abs(sin(p_in.x / halfpi())))) * r
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd02">
		<node name="input_params">
			<real name="designed_3rd02">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd02_init_result(designed_3rd02, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					s = cos(length(p_in) + (length(p_in) + abs(sin(p_in.x * pi())) + cos(abs(sin(p_in.y / pi()))) * sin(abs(cos(p_in.x / pi())))) + abs(sign(p_in.y)))
					t = sin(abs(p_in.x / pi()) + length(p_in) * sin(abs(cos(p_in.y / pi()))) + cos(abs(p_in.x) + sin(abs(sin(p_in.y)))) + sin(abs(cos(p_in.x * pi())) * abs(cos(p_in.y * pi()))))
					z = tan(s / (t / r))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd03">
		<node name="input_params">
			<real name="designed_3rd03">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd03_init_result(designed_3rd03, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					s = tan(sin(abs(p_in.x) - length(p_in) / pi() - sin(abs(cos(p_in.y)))) * sin(abs(p_in.x) + length(p_in) / pi() + sin(abs(cos(p_in.y)))))
					t = tan(sin(abs(p_in.y) - length(p_in) / pi() - sin(abs(cos(p_in.x)))) * sin(abs(p_in.y) + length(p_in) / pi() + sin(abs(cos(p_in.y)))))
					z = fmod(s, t) * tan(s * t) * fourpi()
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd04">
		<node name="input_params">
			<real name="designed_3rd04">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd04_init_result(designed_3rd04, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = sin(abs(sin(p_in.x)) - abs(sin(p_in.y)))
					a2 = cos(abs(cos(p_in.x)) - abs(cos(p_in.y)))
					a = fmod(a1, a2) / tanh(p_in.x)
					b1 = sin(abs(sin(p_in.x)) + abs(sin(p_in.y)))
					b2 = cos(abs(cos(p_in.x)) + abs(cos(p_in.y)))
					b = fmod(b1, b2) / tanh(p_in.y)
					z = fmod(a, b) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd05">
		<node name="input_params">
			<real name="designed_3rd05">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd05_init_result(designed_3rd05, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = sin(abs(cos(p_in.x)) * abs(cos(p_in.y)))
					a2 = cos(abs(sin(p_in.x)) * abs(sin(p_in.y)))
					a = fmod(a2, a1)
					b1 = sin(abs(cos(p_in.x)) / abs(cos(p_in.y)))
					b2 = cos(abs(sin(p_in.x)) / abs(sin(p_in.y)))
					b = fmod(b2, b1)
					z =  tan(if r < twoinvpi() then (fmod(b, a)) else p_in.x + sign(p_in.y))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd06">
		<node name="input_params">
			<real name="designed_3rd06">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd06_init_result(designed_3rd06, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.25 / length(p_in)
					a1 = recip(exp(abs(cos(p_in.x)) * abs(sin(p_in.y))))
					a2 = recip(exp(abs(sin(p_in.x)) / abs(cos(p_in.y))))
					a = fmod(a2, a1)
					b1 = recip(exp(abs(cos(p_in.x)) / abs(sin(p_in.y))))
					b2 = recip(exp(abs(sin(p_in.x)) * abs(cos(p_in.y))))
					b = fmod(b1, b2)
					z = if r < twoinvpi() * 2 then fmod(a, b) else fmod((p_in.y + sign(p_in.x)) * twopi(), tan(p_in.x * pi()))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd07">
		<node name="input_params">
			<real name="designed_3rd07">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd07_init_result(designed_3rd07, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.25 / length(p_in)
					a1 = cos(abs(sin(p_in.x + p_in.y) / pi()) + abs(sin(p_in.x - p_in.y) / pi()))
					a2 = cos(abs(sin(p_in.x) / pi()) + abs(sin(p_in.y) / pi()))
					a = fmod(a1, a2)
					b1 = cos(abs(sin(p_in.x + p_in.y)) - abs(sin(p_in.x - p_in.y)))
					b2 = cos(abs(sin(p_in.x)) - abs(sin(p_in.y)))
					b = fmod(b1, b2)
					ab = a / (b / r)
					c1 = tan(abs(sin(p_in.x + p_in.y) / pi()) + abs(sin(p_in.x - p_in.y) / pi()))
					c2 = tan(abs(sin(p_in.x) / pi()) + abs(sin(p_in.y) / pi()))
					c = fmod(c1, c2)
					d1 = tan(abs(sin(p_in.x + p_in.y)) - abs(sin(p_in.x - p_in.y)))
					d2 = tan(abs(sin(p_in.x)) - abs(sin(p_in.y)))
					d = fmod(d1, d2)
					cd = c / (d / r)
					s = sin(abs(p_in.x + p_in.y) - abs(p_in.x -p_in.y))
					z = fmod(ab, cd) * (s * 2)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd08">
		<node name="input_params">
			<real name="designed_3rd08">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd08_init_result(designed_3rd08, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.25 / length(p_in)
					c = complex(abs(p_in.x), abs(p_in.y))
					a1 = exp(c / pi())
					a2 = c * (sqrt(c + 1.0) / sqrt(c - 1.0))
					a = tan(fmod(length(a2), length(a1)))
					b1 = log(c * pi())
					b2 = c + sqrt(c * c + 1.0)
					b = tan(fmod(length(b1), length(b2)))
					z = tan(a * b)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd09">
		<node name="input_params">
			<real name="designed_3rd09">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd09_init_result(designed_3rd09, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.25 / length(p_in)
					a1 = sin(abs(cos(p_in.x + p_in.y)) + abs(cos(p_in.x - p_in.y)))
					a2 = cos(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y))
					a = fmod(a2, a1)
					b1 = sin(abs(cos(p_in.x)) + abs(cos(p_in.y)))
					b2 = cos(abs(p_in.x) + abs(p_in.y))
					b = fmod(b2, b1)
					z = tan(if r < (abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y)) / fourpi() then a * b else tan((abs(p_in.x) - abs(p_in.y)) * twopi()) * tan(length(p_in * twopi())))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd10">
		<node name="input_params">
			<real name="designed_3rd10">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd10_init_result(designed_3rd10, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = fmod(p_in.x, p_in.y)
					a2 = fmod(p_in.y, p_in.x)
					a = sin(lerp(abs(a1), abs(a2), 0.5))
					b1 = fmod(p_in.x * p_in.y, length(p_in))
					b2 = fmod(length2(p_in), length(p_in))
					b = sin(lerp(abs(b1), abs(b2), 0.5))
					z = if r < twoinvpi() then fmod(b, a) else recip(fmod(b, a)) / pi()
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd11">
		<node name="input_params">
			<real name="designed_3rd11">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd11_init_result(designed_3rd11, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = abs(cos(p_in.x)) + abs(cos(p_in.y))
					b = tan(abs(p_in.x) + abs(p_in.y))
					ab = fmod(a, b)
					c = abs(sin(p_in.x)) + abs(sin(p_in.y))
					d = abs(sin(p_in.x + p_in.y)) + abs(sin(p_in.x - p_in.y))
					z = tan(fmod(fmod(ab, c), d))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd12">
		<node name="input_params">
			<real name="designed_3rd12">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd12_init_result(designed_3rd12, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = abs(tan(p_in.x)) - abs(tan(p_in.y))
					a2 = sin(abs(p_in.x) - abs(p_in.y))
					a = fmod(a2, a1)
					b = (abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y))
					z = tan(fmod(b, a)) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd13">
		<node name="input_params">
			<real name="designed_3rd13">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd13_init_result(designed_3rd13, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = cos(abs(p_in.x / pi()) * abs(cos(sin(p_in.y / pi()))))
					a2 = exp(abs(sin(cos(p_in.x))) + abs(cos(sin(p_in.y))))
					z = fmod(a2, a1) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd14">
		<node name="input_params">
			<real name="designed_3rd14">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd14_init_result(designed_3rd14, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = exp(tan(abs(p_in.x) + abs(p_in.y)) * sin(abs(p_in.y) * halfpi()))
					a2 = exp(tan(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y)) * sin(abs(p_in.x + p_in.y) * halfpi()) * sin(abs(p_in.x - p_in.y) * halfpi()))
					z = fmod(a1, a2)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd15">
		<node name="input_params">
			<real name="designed_3rd15">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd15_init_result(designed_3rd15, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = exp(abs(tan(p_in.x))) * twoinvpi()
					a2 = fmod(exp((abs(p_in.y) + abs(p_in.x)) * invpi()), tanh(abs(p_in.y)) + abs(p_in.x)) * tanh(p_in.x * p_in.y) * exp(cos(abs(p_in.x)))
					a = fmod(a2, a1)
					b1 = exp(cos(abs(sin(p_in.x))))
					b2 = tan(abs(sin(p_in.x)) + cos(abs(p_in.y) + abs(p_in.x)))
					b = fmod(b1, b2)
					z = if r < invpi() then fmod(b, a) else if r < twoinvpi() then fmod(abs(p_in.x) * twopi(), a2) else fmod(tan(p_in.x * p_in.y * fourpi()), b2)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd16">
		<node name="input_params">
			<real name="designed_3rd16">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd16_init_result(designed_3rd16, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = sin(length(p_in) + cos(abs(p_in.x)))
					a2 = cos(length(p_in) + sin(abs(p_in.x)))
					a = clamp(a1, a2, sin(abs(p_in.x) + abs(p_in.y)))
					b = exp(sin(abs(p_in.x)))
					c = (abs(p_in.x) + abs(p_in.y)) * invpi()
					z = if r < c * invpi() then fmod(c, fmod(b, a)) else fmod(b / a - c, p_in.x) / tanh(p_in.x)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd17">
		<node name="input_params">
			<real name="designed_3rd17">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd17_init_result(designed_3rd17, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = exp(abs(sin(p_in.x)) + abs(sin(p_in.y)))
					a2 = (abs(p_in.x) + abs(p_in.y)) * invpi()
					a3 = sin(abs(cos(p_in.x)) + abs(cos(p_in.y)))
					z = if(r < invpi(), fmod(a1, (fmod(a2, a3))), fmod(a2, abs(p_in.x) / a1) * pi())
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd18">
		<node name="input_params">
			<real name="designed_3rd18">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd18_init_result(designed_3rd18, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = mat2x2(cos(abs(p_in.x)), -sin(abs(p_in.y)),
											sin(abs(p_in.x)), cos(abs(p_in.y))) * (p_in * quartpi())
					b = tan(abs(p_in.x + p_in.y) * abs(p_in.x - p_in.y))
					z = if r < twoinvpi() then fmod(b, fmod(a.y, a.x)) else fmod(b, length(p_in)) * pi()
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd19">
		<node name="input_params">
			<real name="designed_3rd19">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd19_init_result(designed_3rd19, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = mat2x2(cos(abs(p_in.x)), -sin(abs(p_in.y)),
											sin(abs(p_in.x)), cos(abs(p_in.y))) * p_in
					a2 = mat2x2(cos(abs(p_in.x)), -sin(abs(p_in.x)),
											sin(abs(p_in.y)), cos(abs(p_in.y))) * p_in
					a = tan(dist(a1, a2))
					b01 = get_t(-abs(p_in.x), abs(p_in.x), tan(abs(p_in.x)))
					b02 = get_t(-abs(p_in.y), abs(p_in.y), tan(abs(p_in.y)))
					b0 = b01 + b02
					b1 = b0 - pi()
					b2 = b0 * invpi()
					b = (b1 + b2)
					z = ((if r < twoinvpi() then fmod(a, b) else fmod(a * twopi(), fmod(b, length(p_in)) * twopi())) *
								if r < halfinvpi()
								then if r < p_in.x * p_in.y
											then halfinvpi()
											else twoinvpi()
								else if r < p_in.x * p_in.y
											then 1.0
											else invpi()) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd20">
		<node name="input_params">
			<real name="designed_3rd20">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd20_init_result(designed_3rd20, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					c1 = complex(abs(p_in.x), abs(p_in.y))
					c2 = complex(length(p_in), length(p_in))
					c = c1 / exp(c2 * sqrt(c1 * c2 + 2.0))
					z01 = get_t(-abs(p_in.x), abs(p_in.x), tan(abs(p_in.x * length(p_in * invpi()) * invpi())))
					z02 = get_t(-abs(p_in.y), abs(p_in.y), tan(abs(p_in.y * length(p_in * invpi()) * invpi())))
					z0 = z01 + z02
					s = abs(sin(p_in.x * pi())) + abs(sin(p_in.y * pi()))
					z1 = fmod(fmod(z0, p_in.x), s)
					z2 = fmod(s, fmod(z0, p_in.y))
					z = (if r < twoinvpi() then if r < length(c) then z1 else z2 else fmod(z01 * pi() + z02 * pi(), tan(p_in.x * p_in.y * fourpi()))) / tanh(p_in.x * p_in.y * length(p_in * invpi()))
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd21">
		<node name="input_params">
			<real name="designed_3rd21">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd21_init_result(designed_3rd21, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					x = exp(sin(abs(cos(p_in.x * twoinvpi()))))
					y = exp(sin(abs(cos(p_in.y * twoinvpi()))))
					z0 = abs(sin(p_in.y * twoinvpi())) + abs(cos(p_in.x * twoinvpi()))
					a1 = (abs(p_in.x) + abs(p_in.y)) * halfinvpi() * halfinvpi()
					a2 = tanh((p_in.x + p_in.y) * (p_in.x - p_in.y))
					a3 = abs(cos(p_in.x)) + abs(sin(p_in.y))
					a = fmod(a3, a1 * a2)
					b1 = sin(length(p_in) + abs(sin(p_in.x)))
					b2 = cos(length(p_in) + abs(cos(p_in.y)))
					b = fmod(b1, b2)
					z = (if r < (abs(p_in.x) + abs(p_in.y)) * halfinvpi() * halfinvpi()
							then if (r > p_in.x + p_in.y && r > p_in.x - p_in.y) || (r > -p_in.x + p_in.y && r > -p_in.x - p_in.y)
										then a
										else b
							else fmod(fmod(x, y), z0)) * sqrt2()
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd22">
		<node name="input_params">
			<real name="designed_3rd22">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd22_init_result(designed_3rd22, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = mat2x2(abs(cos(p_in.x * invpi())), -abs(sin(p_in.y * invpi())),
											abs(sin(p_in.x * invpi())), abs(cos(p_in.y * invpi()))) * p_in
					a2 = mat2x2(cos(abs(p_in.x * invpi())), -sin(abs(p_in.y * invpi())),
											sin(abs(p_in.x * invpi())), cos(abs(p_in.y * invpi()))) * p_in
					f = dist(a, a2)
					z = tan(if r < (abs(p_in.x + p_in.y) + abs(p_in.x- p_in.y)) * (halfinvpi() / twopi()) then tan(f) else fmod(a2.y, a.x) * fmod(a2.y, a.x) * fourpi()) * invpi()
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd23">
		<node name="input_params">
			<real name="designed_3rd23">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd23_init_result(designed_3rd23, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a1 = mat2x2(cos(abs(p_in.x * quartpi())), -sin(abs(p_in.y * quartpi())),
											sin(abs(p_in.x * quartpi())), cos(abs(p_in.y * quartpi()))) * p_in
					a2 = mat2x2(abs(cos(p_in.x * quartpi())), -abs(sin(p_in.y * quartpi())),
											abs(sin(p_in.x * quartpi())), abs(cos(p_in.y * quartpi()))) * p_in
					a = dist(a1, a2)
					b1 = cos(abs(sin((p_in.x + p_in.y) * pi()) / pi()) + abs(sin((p_in.x - p_in.y) * pi()) / pi()))
					b2 = cos(abs(sin(p_in.x * pi()) / pi()) + abs(sin(p_in.y * pi()) / pi()))
					b = fmod(b1, b2)
					c1 = cos(abs(sin((p_in.x + p_in.y) * pi())) - abs(sin((p_in.x - p_in.y) * pi())))
					c2 = cos(abs(sin(p_in.x * pi())) - abs(sin(p_in.y * pi())))
					c = fmod(c1, c2)
					bc = b / (c / r)
					z0 = abs(sin(p_in.x * invpi())) + abs(sin(p_in.y * invpi()))
					z = (if r < a then fmod(a, z0) else bc)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd24">
		<node name="input_params">
			<real name="designed_3rd24">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd24_init_result(designed_3rd24, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = get_t(abs(p_in.x), -abs(p_in.x), tan(abs(p_in.y) * length(p_in)))
					b = get_t(abs(p_in.y), -abs(p_in.y), tan(abs(p_in.x) * length(p_in)))
					ab = (a + b) * r
					c = (tanh(p_in.x * p_in.y * pi()))
					f = (tan(abs(p_in.x) + sin(abs(p_in.y))) * tanh(abs(p_in.y) + sin(abs(p_in.x))))
					z = if r < twoinvpi() then tan(fmod(ab, c) / f) else fmod(ab, p_in.x * twopi())
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_3rd25">
		<node name="input_params">
			<real name="designed_3rd25">1</real>
			<real name="fill" minval="0" maxval="0.5">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed_3rd25_init_result(designed_3rd25, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					r1 = 2 / length(p_in)
					r2 = 0.5 / length(p_in)
					a = exp(abs(cos(p_in.x)) + abs(sin(p_in.y)))
					b = sin(length(p_in) + exp(abs(p_in.x * halfinvpi())))
					c = fmod(b, a) * r
					s = mat2x2(cos(c), -sin(c),
											sin(c), cos(c)) * p_in
					z = fmod(atan2(s.y, abs(s.x)), atan2(s.x, abs(s.y))) / tanh(p_in.x * p_in.y)
					con0 = abs(z) > r1
					con1 = abs(z) < r1 && abs(z) > r2
					con2 = abs(z) < r2
				in
					(if if fill <= 0.0 then con0 else if fill > 0.25 then con2 else con1 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed_dz">
		<!-- designed by bezo97 -->
		<node name="input_params">
			<real name="designed_dz">1</real>
			<real name="designed_dz_fill" minval="0.0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed_dz_init_result(designed_dz, designed_dz_fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = 200.0 * fract(0.0005 * (sin(pi() * (r + (10.0*p_in.y)) )) / (p_in.x * p_in.y))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed">
		<!-- designed by Crystalize! :D -->
		<node name="input_params">
			<real name="designed">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed_init_result(designed, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(sin(p_in.x)) + abs(sin(p_in.y))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed01">
		<!-- designed by Crystalize! :D -->
		<node name="input_params">
			<real name="designed01">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed01_init_result(designed01, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(length(p_in) * (tan(p_in.x * p_in.y) * cos(p_in.y * sin(length(p_in)))) / sinh(p_in.x))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed02">
		<node name="input_params">
			<real name="designed02">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed02_init_result(designed02, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(tan(p_in.x) * cos(p_in.y * p_in.x) * cos(p_in.y))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed03">
		<node name="input_params">
			<real name="designed03">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed03_init_result(designed03, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(tan(fmod(p_in.x, p_in.x / cos(p_in.y))) * tan(p_in.y * (p_in.x * cos(p_in.y))))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed04">
		<node name="input_params">
			<real name="designed04">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed04_init_result(designed04, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(sin(length(p_in * (p_in.x * p_in.y)) / (p_in.y * p_in.x) * halfpi()) * tan(fmod(p_in.x, p_in.x / p_in.y)))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed05">
		<node name="input_params">
			<real name="designed05">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed05_init_result(designed05, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(cos(p_in.x * sin(p_in.y)) * tanh(length(p_in) * p_in.x) * cos(p_in.x))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed06">
		<node name="input_params">
			<real name="designed06">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed06_init_result(designed06, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					l = lerp(p_in.x * p_in.y, p_in.y / p_in.x, 0.5)
					z = abs(cos(l * sin(p_in.y)) * tan(length(p_in)))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed07">
		<node name="input_params">
			<real name="designed07">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed07_init_result(designed07, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					l = lerp(p_in.y, p_in.x, length(p_in) / fourpi() * abs(cos(p_in.x)))
					c = lerp(abs(p_in.x), abs(p_in.y), length(p_in)) * abs(cos(l)) - length(p_in)
					z = abs(sin(p_in.x) * tan(l * c) / cos(l))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed08">
		<node name="input_params">
			<real name="designed08">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed08_init_result(designed08, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(cos(p_in.x + p_in.y * sin(length(p_in)) * abs(sinh(p_in.x / log(p_in.x * p_in.y)))))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed09">
		<node name="input_params">
			<real name="designed09">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed09_init_result(designed09, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					l = lerp(-p_in.y / cos(p_in.x), atan2(p_in.y, p_in.x / p_in.y), if r < halfinvpi() then -length(p_in) else 1 / length(p_in) * fourpi())
					z = abs((p_in.x * p_in.y) * tan(l) * sin(length(p_in)) * if l > r && -l > r then l else r)
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed10">
		<node name="input_params">
			<real name="designed10">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed10_init_result(designed10, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					a = atan2(p_in.x * p_in.y * sinh(p_in.x), abs(p_in.y / cos(p_in.x)))
					a2 = atan2(length(p_in), p_in.x * p_in.y)
					z = abs(cos((a * a2) * (p_in.x * (tan(p_in.y) + sin(p_in.x)))) * (a2))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed11">
		<node name="input_params">
			<real name="designed11">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed11_init_result(designed11, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(cos(p_in.x * cos(p_in.y)) * cos(p_in.y * sin(p_in.x)) / halfpi())
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed12">
		<node name="input_params">
			<real name="designed12">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed12_init_result(designed12, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(length(p_in / fourpi()) / cos(p_in.x) * tan(length(p_in * pi())) * cos(p_in.x * cos(length(p_in)))) / tan(p_in.y * p_in.x * length(p_in) / halfpi())
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed13">
		<node name="input_params">
			<real name="designed13">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed13_init_result(designed13, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = abs(tan(p_in.y * sin(p_in.x + fmod(length(p_in) * p_in.x, cos(p_in.y * tanh(p_in.y))))) * sin(length(p_in) + abs(p_in.y * p_in.x) / (length(p_in) / quartpi())))
					con1 = z < r
					con2 = z > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed14">
		<node name="input_params">
			<real name="designed14">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed14_init_result(designed14, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = sin(length(p_in) + (p_in.y * p_in.x) / (length(p_in) / quartpi())) * tan(length(p_in * fmod(sin(p_in.x / cos(fourpi())), sin(length(p_in)))))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed15">
		<node name="input_params">
			<real name="designed15">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed15_init_result(designed15, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					f = if r < halfinvpi() then cos(p_in.y) * sin(p_in.x) else recip(fmod(length(p_in), atan(p_in.x * p_in.y) / cos(p_in.x)))
					z = cos(length(p_in)) * cos(p_in.x) / atan(tanh(p_in.y * abs(p_in.x)) + sin(p_in.y)) / pi() * tan(length(p_in)) / sin(p_in.x * sin(p_in.y * atan(p_in.x / f)))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed16">
		<node name="input_params">
			<real name="designed16">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed16_init_result(designed16, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = sin(length(p_in) + cos(p_in.y))
					z = s * tan(p_in.x * sin(p_in.y * exp(abs(p_in.x / if r > s then twopi() * p_in.x else s * fourpi()))))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed17">
		<node name="input_params">
			<real name="designed17">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed17_init_result(designed17, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = sin(length(p_in) + log(abs(p_in.y * p_in.x)))
					t = tan(p_in.x) * fract(tan(abs(if r > s then p_in.y else p_in.x * p_in.y))) * s
					u = sin(length(p_in) + abs(p_in.y / p_in.x)) * tan(fract(abs(p_in.x)))
					z = (if s > r then t else u) / s / (length(p_in) / 2.0) * tan(p_in.y)
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed18">
		<node name="input_params">
			<real name="designed18">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed18_init_result(designed18, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					a = p_in * p_in.x
					b = p_in * p_in.y
					zw = complex(length(p_in), length(p_in))
					quat = vec4(a.x * b.x - a.y * b.y - zw.re * zw.im - zw.re * zw.im,
								a.x * b.y + a.y * b.x + zw.re * zw.im - zw.re * zw.im,
								a.x * zw.im - a.y * zw.im + zw.re * b.x + zw.re * b.y,
								a.x * zw.im + a.y * zw.im - zw.re * b.y + zw.re * b.x)
					s = (e0(quat) * e2(quat)) / (e1(quat) * e3(quat))
					t = if r > s then tan(p_in.x) * sin(length(vec2(e0(quat), e2(quat)))) else cos(p_in.y) / fmod(e1(quat), e3(quat)) * fourpi()
					z = t * cos(length(p_in * atan(p_in.x * p_in.y)) * sin(length(p_in) + cos(p_in.y / fourpi()))) * (s / pi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed19">
		<node name="input_params">
			<real name="designed19">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed19_init_result(designed19, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					a = p_in * p_in.x
					b = p_in * p_in.y
					zw = complex(length(p_in), length(p_in))
					quat = vec4(a.x * b.x - a.y * b.y - zw.re * zw.im - zw.re * zw.im,
								a.x * b.y + a.y * b.x + zw.re * zw.im - zw.re * zw.im,
								a.x * zw.im - a.y * zw.im + zw.re * b.x + zw.re * b.y,
								a.x * zw.im + a.y * zw.im - zw.re * b.y + zw.re * b.x)
					s = (e0(quat) * e2(quat)) / (e1(quat) * e3(quat))
					z = (if r < invpi() then (cos(s) / pi()) * sin(length(p_in) - s * pi()) else p_in.x * s / fourpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed20">
		<node name="input_params">
			<real name="designed20">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed20_init_result(designed20, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = log(abs(length(p_in) * (p_in.x + p_in.y))) * log(abs(length(p_in) * (p_in.x - p_in.y))) * (p_in.x / p_in.y) / pi()
					t = (sin(p_in.x * sin(length(p_in) / twopi() + cos(p_in.y + twopi()))) * s) / fourpi()
					u = tan(p_in.x)
					v = tan(p_in.y)
					z = (if s > t then u else v) / (twopi() * fmod(length(p_in * (s / twopi())), halfpi() / length(p_in))) / fourpi()
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed21">
		<node name="input_params">
			<real name="designed21">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed21_init_result(designed21, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = if r > halfinvpi() then sin(p_in.x) else cos(p_in.y)
					z = s * sin(length(p_in)) * exp((p_in.x + p_in.y) / (p_in.x - p_in.y)) / tan(p_in.x + p_in.y) * s
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed22">
		<node name="input_params">
			<real name="designed22">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed22_init_result(designed22, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					z = cos(p_in.y * sin(length(p_in)) / tan(abs(p_in.y) + abs(p_in.x))) / tan(p_in.x * sin(length(p_in)) / tan(p_in.x)) * tan(p_in.y * sin(length(p_in)) * exp(abs(p_in.y))) / length(p_in)
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed23">
		<node name="input_params">
			<real name="designed23">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed23_init_result(designed23, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = cos(abs(p_in.x) + abs(p_in.y))
					t = tan(length(p_in * s * r) * length(p_in / p_in.x))
					u = tan(length(p_in * s * r) * length(p_in / p_in.y))
					v = if r > s then t else u
					z = v * tan((p_in.x + p_in.y) - (p_in.x - p_in.y)) * (r * halfpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed24">
		<node name="input_params">
			<real name="designed24">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_gauss_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed24_init_result(designed24, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = lerp(cos(abs(p_in.y)), sin(abs(p_in.x)), 0.5)
					t = cos(p_in.x * s) * sin(p_in.y / s) * atan2(s * pi(), cos(s)) * (p_in.x * fourpi())
					z = t * (r * if r < gauss_rnd_0 * (halfinvpi() / 2.0) then fourpi() else halfinvpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed25">
		<node name="input_params">
			<real name="designed25">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed25_init_result(designed25, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = recip(p_in.x * p_in.y / tan(length(p_in)))
					t = fmod(p_in.x, p_in.y) / tan(length(p_in))
					u = tan((p_in.x + p_in.y) * (p_in.x - p_in.y)) / r
					z = tan(s * (cos(p_in.x) * fourpi()) / (t * tan(p_in.y)) * u) / tanh(p_in.x * tan(p_in.y * sin(length(p_in) * p_in.x)) * cos(u)) * r
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed26">
		<node name="input_params">
			<real name="designed26">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed26_init_result(designed26, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = sin(length(p_in) + sin(abs(p_in.x)))
					t = sin(length(p_in) + sin(abs(p_in.y)))
					u = lerp(s, t, 0.5)
					v = fmod(s / t * r / u, length(p_in) * cos(u))
					z = u * v
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed27">
		<node name="input_params">
			<real name="designed27">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed27_init_result(designed27, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = sin((p_in.x + p_in.y) * (p_in.x - p_in.y) / twopi())
					t = cos(p_in.x * p_in.y / pi())
					u = tan(length(p_in * s * t)) * r
					z = (if r < twoinvpi() then u else p_in.y + sign(p_in.x))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed28">
		<node name="input_params">
			<real name="designed28">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed28_init_result(designed28, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = sin((abs(p_in.x) + abs(p_in.y)) * pi())
					t = cos((p_in.x + p_in.y) * (p_in.x - p_in.y) / pi())
					u = sin((abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y)) * pi())
					v = sin(p_in.x * p_in.y / pi())
					z = recip(if r < twoinvpi() then s * u / t / v else recip(s * u / t / v)) / twopi()
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed29">
		<node name="input_params">
			<real name="designed29">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed29_init_result(designed29, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan((p_in.x + p_in.y) + sign(p_in.x - p_in.y))
					t = tan((p_in.x - p_in.y) + sign(p_in.x + p_in.y))
					u = tan(p_in.x + sign(p_in.y))
					v = tan(p_in.y - sign(p_in.x))
					z = tan(tan((s * t) + (u * v)) * r)
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed30">
		<node name="input_params">
			<real name="designed30">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed30_init_result(designed30, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(p_in.x * (p_in.x + p_in.y) / pi())
					t = tan(p_in.y * (p_in.x - p_in.y) / pi())
					u = cos(s * t)
					z = if r < twoinvpi() then sin(s * t * u) else fmod(p_in.x * fourpi(), p_in.y * fourpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed31">
		<node name="input_params">
			<real name="designed31">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed31_init_result(designed31, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(abs(p_in.x) + abs(p_in.y))
					t = tan(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y))
					u = lerp(s, t, length(p_in) / 2.0) * r
					v = atan2(u / quartpi(), u * (u / halfinvpi()))
					z = if r > twoinvpi() then p_in.x + sign(p_in.y) else v
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed32">
		<node name="input_params">
			<real name="designed32">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed32_init_result(designed32, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(abs(p_in.x) + abs(p_in.y))
					t = tan(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y))
					u = lerp(s, t, length(p_in) / 2.0) * r
					v = tan(u) / tan(length(p_in)) + abs(p_in.x) * (r / pi())
					z = tan(lerp(u, v, 0.5))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed33">
		<node name="input_params">
			<real name="designed33">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed33_init_result(designed33, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(abs(p_in.x) + abs(p_in.y))
					t = tan(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y))
					u = lerp(s, t, 0.5)
					v = tan(lerp(tan(length(p_in)), u, 0.5))
					w = tan(s * t)
					z = lerp(v, w, 0.5) * (r * halfpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed34">
		<node name="input_params">
			<real name="designed34">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<string name="winter_init_function">
			<![CDATA[
				designed34_init_result(designed34, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = cos(p_in.x / (sin(abs(p_in.y) * abs(sin(p_in.y)) + abs(p_in.x * sin(length(p_in))))))
					t = tan(length(p_in) + abs(sin(p_in.x * (tan(p_in.y / length(p_in)))))) * (s / fourpi())
					z = tan(lerp(s, t, 0.25) * (r * halfpi()))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed35">
		<node name="input_params">
			<real name="designed35">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed35_init_result(designed35, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(length(p_in) + cos(abs(sin(p_in.x) * tan(length(p_in) + abs(sin(p_in.y))))))
					t = tan(abs(p_in.x) + abs(p_in.y)) / tan(length(p_in) + abs(tan(p_in.x) * (abs(tan(p_in.y)) * tan(fourpi()))) + abs(cos(p_in.x)))
					z = tan(lerp(s, t, r)) * (r * halfpi())
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed36">
		<node name="input_params">
			<real name="designed36">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed36_init_result(designed36, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = tan(length(p_in) + tan(abs(sin(p_in.x))) + abs(fmod(p_in.x, p_in.y) * twopi()) * sin(length(p_in) + tan(abs(p_in.x) - abs(p_in.y))) + abs(p_in.x) * sin(abs(p_in.y)))
					z = tan((tan(fmod(abs(p_in.x + p_in.y) + abs(p_in.x - p_in.y), length(p_in))) * s) * r)
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>

	<transform_def name="designed37">
		<node name="input_params">
			<real name="designed37">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed37_init_result(designed37, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s = cos(length(p_in) * sin(length(p_in) + tan(abs(sin(p_in.y))) + sin(abs(cos(p_in.x))) + cos(length(p_in) + cos(abs(sin(p_in.y))))))
					t = tan(cos(length(p_in) + cos(abs(p_in.x * halfpi()) + sin(abs(cos(p_in.y)))))) * r
					u = (t / s) * r
					v = tan(lerp(u, s, 0.5) / 2.0)
					w = sin(abs(p_in.x) + length(p_in))
					z = (if r * s < invpi() then v else w)
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>
	<transform_def name="designed38">
		<node name="input_params">
			<real name="designed38">1</real>
			<real name="fill" minval="0" maxval="0.005">0</real>
		</node>
		<node name="internal_params">
			<real name="weight" />
			<real name="fill" />
		</node>
		<int name="num_unit_randoms">1</int>
		<string name="winter_init_function">
			<![CDATA[
				designed38_init_result(designed38, fill)
			]]>
		</string>
		<string name="winter_eval_function">
			<![CDATA[
				let
					r = 1 / length(p_in)
					s1 = cos((length(p_in) / recip(p_in.x * p_in.y / fourpi()) * (abs(cos(p_in.x * halfpi())) + abs(sin(p_in.y * halfpi())))) * (abs(cos(p_in.y * halfpi())) + abs(sin(p_in.x * halfpi()))))
					s2 = cos((length(p_in) * (abs(cos(p_in.x * halfpi())) + abs(sin(p_in.y * halfpi())))) * (abs(cos(p_in.y * halfpi())) + abs(sin(p_in.x * halfpi()))))
					s = if r < halfinvpi() then s1 else s2
					z = (s * (r * halfpi()))
					con1 = abs(z) < r
					con2 = abs(z) > r
				in
					(if if fill > 0.0 then con1 else con2 then p_in else vec2(0.0)) * weight
			]]>
		</string>
	</transform_def>
</user_transforms>