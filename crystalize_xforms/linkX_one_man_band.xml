<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_one_man_band">
		<!-- xform made by Crystalize, but honestly it couldn't have been done without the whole community.
			Thanks ya'll! <3 -->
		<node name="input_params">
			<real name="one_man_band" minval="0">1</real>
			<real name="one_man_band_cyl_length">10</real>
			<real name="one_man_band_cyl_width" minval="0.0" maxval="0.95">0.05</real>
			<real name="one_man_band_cyl_blur_strength">1</real>
			<real name="one_man_band_inside_rotate">0</real>
			<real name="one_man_band_inside_switch" minval="0.0" maxval="0.005">0</real>
			<real name="one_man_band_outside_switch" minval="0.0" maxval="0.005">0</real>
			<real name="one_man_band_inner_weight1" minval="0.0" maxval="1.0">0.5</real>
			<real name="one_man_band_inner_weight2" minval="0.0" maxval="1.0">0.99</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="cl" />
			<real name="cw" />
			<real name="clbs" />
			<real name="bpr" />
			<real name="terp1" />
			<real name="terp2" />
			<real name="iw1" />
			<real name="iw2" />
		</node>

		<int name="num_unit_randoms">3</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_one_man_band_init_result(one_man_band, one_man_band_cyl_length, one_man_band_cyl_width - 0.05, one_man_band_cyl_blur_strength,
							one_man_band_inside_rotate * quartpi(), one_man_band_inside_switch,
							one_man_band_outside_switch, one_man_band_inner_weight1, one_man_band_inner_weight2)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					rotm = mat2x2(cos(bpr), -sin(bpr),
							sin(bpr), cos(bpr))
					bpin = rotm * p_in
					z = complex(bpin.y, bpin.x)
					result = ((weight * invpi()) * (0.9 - cw)) * log((-z + 1.0) / (z + 1.0))
					result2 = ((weight * twoinvpi()) * (0.9 - cw)) * log(z + sqrt(z * z + 1.0))
					ast_out = lerp(vec2(result.im, result.re),
							vec2(result2.im, result2.re),
							if terp1 <= 0.0 then 0.0 else 1.0)

					scale = weight / (dot(p_in, p_in))
					x_off = if p_in.x >= 0 then (1.0 + cw) else (-1.0 - cw)
					sp_out = (if terp2 <= 0.0 then p_in else p_in * scale) + vec2(x_off, 0.0) * weight

					a = unit_rnd_0 * twopi()
					s = gauss_rnd_0 * clbs
					g = vec2(cos(a), sin(a)) * s + p_in
					cyl1 = vec2((g.x * (1.0 + (cw * (halfinvpi() * 10.0 * fourpi())))) / sqrt(g.x * g.x + 1.0) - 19.0, g.y * (1.0 + cl)) * (weight * 0.05)
					cyl2 = vec2((g.x * (1.0 + (cw * (halfinvpi() * 10.0 * fourpi())))) / sqrt(g.x * g.x + 1.0) + 19.0, g.y * (1.0 + cl)) * (weight * 0.05)
				in
					lerp(lerp(ast_out, sp_out, if unit_rnd_0 >= iw1
									then 1.0
									else 0.0), lerp(cyl1, cyl2, if unit_rnd_1 >= 0.5
													then 1.0
													else 0.0), if unit_rnd_2 >= iw2
															then 1.0
															else 0.0)
			]]>
		</string>
	</transform_def>
</user_transforms>
