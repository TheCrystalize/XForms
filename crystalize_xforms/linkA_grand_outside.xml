<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkA_grand_outside">
		<node name="input_params">
			<real name="le_grand_julien">1</real>
			<real name="le_grand_julien_inside_ring" minval="0.0" maxval="1.0">0.0</real>
			<real name="le_grand_julien_inside_power">2</real>
			<real name="le_grand_julien_inside_dist">1</real>
			<real name="le_grand_julien_inside_size" minval="0.0">0.5</real>
			<real name="le_grand_julien_inside_adjust">0.0</real>
			<real name="le_grand_julien_outside_ring" minval="0.0">0.2</real>
			<real name="le_grand_julien_outside_power">3</real>
			<real name="le_grand_julien_outside_dist">-1</real>
			<real name="le_grand_julien_outside_size">1.5</real>
			<real name="le_grand_julien_outside_adjust">1.0</real>
			<real name="le_grand_julien_a">1</real>
			<real name="le_grand_julien_b">0</real>
			<real name="le_grand_julien_c">0</real>
			<real name="le_grand_julien_d">1</real>
			<real name="le_grand_julien_e">0</real>
			<real name="le_grand_julien_f">0</real>
			<real name="le_grand_julien_inner_weight1" minval="0.0" maxval="1.0">0.5</real>
			<real name="le_grand_julien_inner_weight2" minval="0.0" maxval="1.0">0.1</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="iring" />
			<real name="ipower" />
			<real name="idist" />
			<real name="isize" />
			<real name="iadjust" />
			<real name="oring" />
			<real name="opower" />
			<real name="odist" />
			<real name="osize" />
			<real name="oadjust" />
			<real name="a" />
			<real name="b" />
			<real name="c" />
			<real name="d" />
			<real name="e" />
			<real name="f" />
			<real name="iw1" />
			<real name="iw2" />
		</node>

		<int name="num_unit_randoms">11</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkA_grand_outside_init_result(le_grand_julien, le_grand_julien_inside_ring, le_grand_julien_inside_power, le_grand_julien_inside_dist / le_grand_julien_inside_power * 0.5, le_grand_julien_inside_size, le_grand_julien_inside_adjust,
					le_grand_julien_outside_ring, le_grand_julien_outside_power, le_grand_julien_outside_dist / le_grand_julien_outside_power * 0.5, le_grand_julien_outside_size, le_grand_julien_outside_adjust, le_grand_julien_a, le_grand_julien_b, le_grand_julien_c,
					le_grand_julien_d, le_grand_julien_e, le_grand_julien_f, le_grand_julien_inner_weight1, le_grand_julien_inner_weight2)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					rosize = osize - oring
					risize = if isize - iring >= 0.0
										then if isize - iring >= rosize
													then rosize
													else isize - iring
										else 0.0
					misize = if isize >= rosize
										then rosize
										else isize

					rooti = truncateToInt(ipower * unit_rnd_0)
					ai = (atan2(p_in.y, p_in.x) + toReal(rooti) * twopi()) / ipower
					ri = (((isize + osize) / 2) + iadjust) * pow(dot(p_in, p_in), idist)

					x = a * p_in.x + b * p_in.y + e
					y = c * p_in.x + d * p_in.y + f
					rooto = truncateToInt(opower * unit_rnd_1)
					ao = (atan2(y, x) + toReal(rooto) * twopi()) / opower
					ro = (osize + oadjust) * pow(x * x + y * y, odist)

					ijulian = vec2(cos(ai), sin(ai)) * ri
					ojulian = vec2(cos(ao), sin(ao)) * ro

					ir_min = min(rosize, misize)
					ir_max = max(rosize, misize)
					irad = length(ijulian)
					iang = atan2(ijulian.y, ijulian.x)
					is = sin(iang)
					ic = cos(iang)
					icrop = if irad > ir_max || irad < ir_min
									then if 1.0 == 1.0
											then vec2(0.0, 0.0)
											else vec2(ic, is) * (ir_max)
									else ijulian

					or_min = min(osize, 10000000)
					or_max = max(osize, 10000000)
					orad = length(ojulian)
					oang = atan2(ojulian.y, ojulian.x)
					os = sin(oang)
					oc = cos(oang)
					ocrop = if orad > or_max || orad < or_min
									then if 1.0 == 1.0
											then vec2(0.0, 0.0)
											else vec2(oc, os) * (or_max)
									else ojulian

					blrad = osize * sqrt(unit_rnd_8)
					bangle = unit_rnd_9 * twopi()
					blur = vec2(cos(bangle), sin(bangle)) * blrad

					bir_min = min(misize, risize)
					bir_max = max(misize, risize)
					brad = length(blur)
					bang = atan2(blur.y, blur.x)
					bs = sin(bang)
					bc = cos(bang)
					bicrop = if brad > bir_max || brad < bir_min
										then if 1.0 == 1.0
													then vec2(0.0, 0.0)
													else vec2(bc, bs) * (bir_max)
										else blur

					bor_min = min(rosize, osize)
					bor_max = max(rosize, osize)
					bocrop = if brad > bor_max || brad < bor_min
										then if 1.0 == 1.0
													then vec2(0.0, 0.0)
													else vec2(bc, bs) * (bor_max)
										else blur
					iocrop = if unit_rnd_4 <= iw1 then icrop else ocrop
					biocrop = if unit_rnd_5 <= 0.5 then bicrop else bocrop
				in
					(if unit_rnd_10 <= iw2 then iocrop else biocrop) * weight
			]]>
		</string>
	</transform_def>
</user_transforms>
