<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_the_ringer">
		<node name="input_params">
			<real name="the_ringer">1</real>
			<real name="the_ringer_split" minval="0">0.5</real>
			<real name="the_ringer_inside_rotate">2</real>
			<real name="the_ringer_inside_size">1</real>
			<real name="the_ringer_inside_switch" minval="0" maxval="1">0.0</real>
			<real name="the_ringer_inner_weight" minval="0" maxval="1">0.75</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="split" />
			<real name="isr" />
			<real name="iss" />
			<real name="iswitch" />
			<real name="iw" />
		</node>

		<int name="num_unit_randoms">3</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_the_ringer_init_result(the_ringer, the_ringer_split, the_ringer_inside_rotate * quartpi(), the_ringer_inside_size, the_ringer_inside_switch, the_ringer_inner_weight)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					r = length(p_in)
					csplit = if r < 1.0 - split
										then p_in
										else let
											a = atan2(p_in.y, p_in.x)
										in
											vec2(cos(a), sin(a)) * (r + split)

					rotm = mat2x2(cos(isr), -sin(isr),
												sin(isr), cos(isr))
					rlin = rotm * p_in * iss

					z = complex(rlin.x, rlin.y)
					result = invpi() * log((z + 1.0) / (-z + 1.0))
					arctanh = vec2(result.re, result.im)
					result2 = twoinvpi() * log(z + sqrt(z * z + 1.0))
					arcsinh = vec2(result2.re, result2.im)

					b = unit_rnd_0 * twopi()
					t = gauss_rnd_0 * iss
					rgauss = vec2(cos(b), sin(b)) * t + rlin
					hemisphere = rgauss * (1.0 / sqrt(dot(rgauss, rgauss) + 1))

					r2 = dot(p_in, p_in)
					spher = if r2 >1
									then if unit_rnd_1 < 0.5
												then rlin / r2
												else rlin
									else vec2(0.0, 0.0)

					inside = (if iswitch <= 0.0
										then rlin
										else if iswitch <= 0.25
													then arctanh
													else if iswitch <= 0.5
																then arcsinh
																else if iswitch <= 0.75
																			then hemisphere
																			else spher) * (if split < 1.0
																											then 1.0
																											else split)
					rb = length(inside)
					c_in = if split < 1.0
									then (1.0 - split)
									else 0.0
					c_out = if split > 1.0
									then split
									else 1.0
					r_min = min(c_in, c_out)
					r_max = max(c_in, c_out)
					ang = atan2(inside.y, inside.x)
					s = sin(ang)
					c = cos(ang)
					ccrop = if rb > r_max || rb < r_min
									then if 1.0 == 1.0
												then vec2(0.0, 0.0)
												else vec2(c, s) * c_out
									else inside
				in
					lerp(csplit, ccrop, if unit_rnd_2 >= iw
															then 1.0
															else 0.0) * (weight)
			]]>
		</string>
	</transform_def>
</user_transforms>
