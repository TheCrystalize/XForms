<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_tiled_squares">
		<node name="input_params">
			<real name="tiled_squares">1</real>
			<real name="tiled_squares_inside_rotate">0</real>
			<real name="tiled_squares_inside_size">1</real>
			<real name="tiled_squares_inside_switch" minval="0" maxval="1">0</real>
			<real name="tiled_squares_tile_strength" minval="0.5">1</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="atr" />
			<real name="size" />
			<real name="iswitch" />
			<real name="strength" />
		</node>

		<int name="num_unit_randoms">4</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_tiled_squares_init_result(tiled_squares, tiled_squares_inside_rotate * quartpi(), tiled_squares_inside_size, tiled_squares_inside_switch, tiled_squares_tile_strength)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					rotm = mat2x2(cos(atr), -sin(atr),
												sin(atr), cos(atr))
					atin = rotm * (p_in * size)
					z = complex(atin.x, atin.y)
					result = (halfinvpi()) * log((z + 1.0) / (-z + 1.0))
					at_out = vec2(result.im, result.re)
					result2 = (invpi()) * log(z + sqrt(z * z + 1.0))
					as_out = vec2(result2.im, result2.re)
					catx = clamp(if iswitch == 0 then atin.x else if iswitch == 1.0 then as_out.x else at_out.x, -0.5, 0.5)
					caty = clamp(if iswitch == 0 then atin.y else if iswitch == 1.0 then as_out.y else at_out.y, -0.5, 0.5)
					cat = vec2(fract(catx), fract(caty))
					log_out1 = vec2(cat.y, cat.x + floor(log(unit_rnd_0) * (if unit_rnd_1 < 0.5
																															then strength
																															else -strength) + 0.5))
					log_out2 = vec2(log_out1.x + floor(log(unit_rnd_3) * (if unit_rnd_2 < 0.5
																															then strength
																															else -strength) + 0.5), log_out1.y)
				in
					log_out2 * weight
			]]>
		</string>
	</transform_def>
</user_transforms>
