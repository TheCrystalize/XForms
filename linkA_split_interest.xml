<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkA_split_interest">
		<node name="input_params">
			<real name="split_interest" minval="0.0">1</real>
			<real name="split_interest_split">0</real>
			<real name="split_interest_spread">0</real>
			<real name="split_interest_symmetry_type" minval="0.0" maxval="0.05">0</real>
			<real name="split_interest_interest_type" minval="0.0" maxval="0.5">0</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="split" />
			<real name="spread" />
			<real name="syty" />
			<real name="inty" />
		</node>

		<int name="num_unit_randoms">2</int>

		<string name="winter_init_function">
			<![CDATA[
				linkA_split_interest_init_result(split_interest, split_interest_split, split_interest * (split_interest_spread + 2), split_interest_symmetry_type, split_interest_interest_type)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					x_plus_weight = p_in.x + weight
					x_less_weight = p_in.x - weight
					num = x_plus_weight * x_plus_weight + p_in.y * p_in.y
					den = x_less_weight * x_less_weight + p_in.y * p_in.y
					a = (atan2(p_in.y, x_less_weight) - atan2(p_in.y, x_plus_weight)) * 0.5
					r = spread * sqrt(sqrt(num / den))
					fluxa = vec2(cos(a), sin(a)) * r
					fluxb = vec2(-cos(a), if syty == 0.0 then -sin(a) else sin(a)) * r
					rflux = if unit_rnd_0 >= 0.5 then fluxa else fluxb

					d = dot(p_in, p_in)
					r_avg = weight * sqrt(1 + 4 * p_in.x / (d - spread * p_in.x + 1.0))
					a_avg = 0.5 * atan2(spread * p_in.y, (d - 1))
					deltaa = vec2(cos(a_avg), sin(a_avg)) * r_avg
					deltab = vec2(-cos(a_avg), if syty == 0.0 then -sin(a_avg) else sin(a_avg)) * r_avg
					rdelta = if unit_rnd_0 >= 0.5 then deltaa else deltab

					r2 = length(p_in)
					a2 = atan2(p_in.y, p_in.x) + (spread - 2.0) * r2
					c2 = floor(a2 * halfinvpi() + 0.5)
					alpha = a2 * 0.5 + c2 * pi()
					wedgea = vec2(cos(alpha), sin(alpha)) * (r2 * weight)
					wedgeb = vec2(-cos(alpha), if syty == 0.0 then -sin(alpha) else sin(alpha)) * (r2 * weight)
					rwedge = if unit_rnd_0 >= 0.5 then wedgea else wedgeb

					interest = if inty == 0.0 then rflux else if inty == 0.5 then rwedge else rdelta
					x_offset = if interest.x >= 0 then split else -split
				in
					interest + vec2(x_offset, 0.0)
			]]>
		</string>
	</transform_def>
</user_transforms>
