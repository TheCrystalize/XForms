<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="inverseSchwarzChristoffel">
		<node name="input_params">
			<real name="inverseSchwarzChristoffel">1</real>
			<real name="inverseSchwarzChristoffel_K">3</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="K" />
			<real name="cn1" />
			<real name="cn2" />
			<real name="cn3" />
			<real name="cn4" />
			<real name="cn5" />
			<real name="C" />
		</node>

		<int name="num_unit_randoms">2</int>

		<string name="winter_init_function">
			<![CDATA[
				let
					K = inverseSchwarzChristoffel_K
					cn1 = binomial(2.0 / K, 1) / (1.0 + K)
					cn2 = binomial(1.0 + 2.0 / K, 2) / (1.0 + 2.0 * K)
					cn3 = binomial(2.0 + 2.0 / K, 3) / (1.0 + 3.0 * K)
					cn4 = binomial(3.0 + 2.0 / K, 4) / (1.0 + 4.0 * K)
					cn5 = binomial(4.0 + 2.0 / K, 5) / (1.0 + 5.0 * K)
					C = beta(1.0 / K, 1.0 - 2.0 / K) / K
				in
					inverseSchwarzChristoffel_init_result(inverseSchwarzChristoffel, K, cn1, cn2, cn3, cn4, cn5, C)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					z = complex(p_in) * C
					h = cpow(z, K)
					t1 = -cn1
					t2 = -cn2 + (K + 1.0) * pow(cn1, 2.0)
					t3 = -cn3 + (3.0 * K + 2.0) * (cn1 * cn2 - (K + 1.0) / 2.0 * pow(cn1, 3.0))
					t4 = -cn4 + (2.0 * K + 1.0) * (2.0 * cn1 * cn3 + pow(cn2, 2.0) - (4.0 * K + 3.0) * (pow(cn1,2.0) * cn2 - (K+1) / 3.0 * pow(cn1 , 4.0)))
					t5 = -cn5 + (5.0 * K + 2.0) * (cn1 * cn4 + cn2 * cn3 + (5.0 * K + 3.0) * (-0.5 * pow(cn1, 2.0) * cn3 - 0.5 * cn1 * pow(cn2, 2.0) + (5.0 * K + 4.0) * (pow(cn1, 3.0) * cn2 / 6.0 - (K + 1.0) * pow(cn1, 5.0) / 24.0)))
					X = h / pow(C, K) + 1.0
					w = z * (t1 * h + t2 * cpow(h, 2.0) + t3 * cpow(h, 3.0) + t4 * cpow(h, 4.0) + (t5 * cpow(h, 5.0)) / X + 1.0)
				in
					toVec2(w) * weight
			]]>
		</string>
	</transform_def>


</user_transforms>
