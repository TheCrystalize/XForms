<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_get_squared">
		<node name="input_params">
			<real name="get_squared">1</real>
			<real name="get_squared_inside_rotate">0</real>
			<real name="get_squared_inside_size">1</real>
			<real name="get_squared_inside_switch" minval="0" maxval="1.0">0</real>
			<real name="get_squared_outside_switch" minval="0" maxval="0.05">0</real>
			<real name="get_squared_inner_weight" minval="0" maxval="1.0">0.5</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="isr" />
			<real name="iss" />
			<real name="iswitch" />
			<real name="oswitch" />
			<real name="iw" />
		</node>

		<int name="num_unit_randoms">3</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_get_squared_init_result(get_squared, get_squared_inside_rotate * quartpi(), get_squared_inside_size, get_squared_inside_switch, get_squared_outside_switch, get_squared_inner_weight)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					scale = 1.0 / dot(p_in, p_in)
					hole = (if oswitch == 0
									then p_in
									else p_in * scale) + normalise(p_in)
					s = length(hole)
					a1 = atan2(hole.y, hole.x)
					a = if a1 < 0.0 then a1 + twopi() else a1
					p = s * a * 1.2732395447351626861510701069801
					square_out = if p <= s
										then vec2(s, p)
										else if p <= 3.0 * s
													then vec2(2.0 * s - p, s)
													else if p <= 5.0 * s
																then vec2(-s, 4.0 * s - p)
																else if p <= 7.0 * s
																			then vec2(-6.0 * s + p, -s)
																			else vec2(s, -8.0 * s + p)

					rotm = mat2x2(cos(isr), -sin(isr),
												sin(isr), cos(isr))
					rlin = rotm * (p_in *  iss)

					z = complex(rlin.x, rlin.y)
					result = invpi() * log((z + 1.0) / (-z + 1.0))
					arctanh = vec2(result.re, result.im)
					result2 = twoinvpi() * log(z + sqrt(z * z + 1.0))
					arcsinh = vec2(result2.re, result2.im)

					b = unit_rnd_0 * twopi()
					t = gauss_rnd_0 * iss
					rgauss = vec2(cos(b), sin(b)) * t + rlin
					sinusoidal = vec2(sin(rgauss.x), sin(rgauss.y))

					r2 = dot(p_in, p_in)
					squar = if r2 >1
									then if unit_rnd_1 < 0.5
												then rlin / r2
												else rlin
									else vec2(0.0, 0.0)

					inside = if iswitch <= 0.0
										then rlin
										else if iswitch <= 0.25
													then arctanh
													else if iswitch <= 0.5
																then arcsinh
																else if iswitch <= 0.75
																			then sinusoidal
																			else squar
					cinx = clamp(inside.x, -1.0, 1.0)
					ciny = clamp(inside.y, -1.0, 1.0)
					r_in = vec2(cinx, ciny)
				in
					lerp(square_out, r_in, if unit_rnd_2 >= iw
					 												then 1.0
																	else 0.0) * weight
			]]>
		</string>
	</transform_def>
</user_transforms>
