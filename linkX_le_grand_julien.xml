<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_le_grand_julien">
		<node name="input_params">
			<real name="le_grand_julien">1</real>
			<real name="le_grand_julien_fill_rotate">1</real>
			<real name="le_grand_julien_fill_size">1</real>
			<real name="le_grand_julien_fill_switch" minval="0.0" maxval="1.0">0</real>
			<real name="le_grand_julien_inside_ring" minval="0.0" maxval="1.0">0.1</real>
			<real name="le_grand_julien_inside_power">2</real>
			<real name="le_grand_julien_inside_dist">1</real>
			<real name="le_grand_julien_inside_size" minval="0.0">0.5</real>
			<real name="le_grand_julien_inside_adjust">0.0</real>
			<real name="le_grand_julien_outside_ring" minval="0.0">0.2</real>
			<real name="le_grand_julien_outside_power">3</real>
			<real name="le_grand_julien_outside_dist">-1</real>
			<real name="le_grand_julien_outside_size">1.5</real>
			<real name="le_grand_julien_outside_adjust">1.0</real>
			<real name="le_grand_julien_a">1</real>
			<real name="le_grand_julien_b">0</real>
			<real name="le_grand_julien_c">0</real>
			<real name="le_grand_julien_d">1</real>
			<real name="le_grand_julien_e">0</real>
			<real name="le_grand_julien_f">0</real>
			<real name="le_grand_julien_inner_weight1" minval="0.0" maxval="1.0">0.5</real>
			<real name="le_grand_julien_inner_weight2" minval="0.0" maxval="1.0">0.1</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="rot" />
			<real name="fsize" />
			<real name="fswitch" />
			<real name="iring" />
			<real name="ipower" />
			<real name="idist" />
			<real name="isize" />
			<real name="iadjust" />
			<real name="oring" />
			<real name="opower" />
			<real name="odist" />
			<real name="osize" />
			<real name="oadjust" />
			<real name="a" />
			<real name="b" />
			<real name="c" />
			<real name="d" />
			<real name="e" />
			<real name="f" />
			<real name="iw1" />
			<real name="iw2" />
		</node>

		<int name="num_unit_randoms">12</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_le_grand_julien_init_result(le_grand_julien, le_grand_julien_fill_rotate, le_grand_julien_fill_size, le_grand_julien_fill_switch, le_grand_julien_inside_ring, le_grand_julien_inside_power, le_grand_julien_inside_dist / le_grand_julien_inside_power * 0.5, le_grand_julien_inside_size, le_grand_julien_inside_adjust,
					le_grand_julien_outside_ring, le_grand_julien_outside_power, le_grand_julien_outside_dist / le_grand_julien_outside_power * 0.5, le_grand_julien_outside_size, le_grand_julien_outside_adjust, le_grand_julien_a, le_grand_julien_b, le_grand_julien_c,
					le_grand_julien_d, le_grand_julien_e, le_grand_julien_f, le_grand_julien_inner_weight1, le_grand_julien_inner_weight2)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					rosize = osize - oring
					risize = if isize - iring >= 0.0
										then if isize - iring >= rosize
													then rosize
													else isize - iring
										else 0.0
					misize = if isize >= rosize
										then rosize
										else isize

					rooti = truncateToInt(ipower * unit_rnd_0)
					ai = (atan2(p_in.y, p_in.x) + toReal(rooti) * twopi()) / ipower
					ri = (((isize + osize) / 2) + iadjust) * pow(dot(p_in, p_in), idist)

					x = a * p_in.x + b * p_in.y + e
					y = c * p_in.x + d * p_in.y + f
					rooto = truncateToInt(opower * unit_rnd_1)
					ao = (atan2(y, x) + toReal(rooto) * twopi()) / opower
					ro = (osize + oadjust) * pow(x * x + y * y, odist)

					ijulian = vec2(cos(ai), sin(ai)) * ri
					ojulian = vec2(cos(ao), sin(ao)) * ro

					ir_min = min(rosize, misize)
					ir_max = max(rosize, misize)
					irad = length(ijulian)
					iang = atan2(ijulian.y, ijulian.x)
					is = sin(iang)
					ic = cos(iang)
					icrop = if irad > ir_max || irad < ir_min
									then if 1.0 == 1.0
											then vec2(0.0, 0.0)
											else vec2(ic, is) * (ir_max)
									else ijulian

					or_min = min(osize, 10000000)
					or_max = max(osize, 10000000)
					orad = length(ojulian)
					oang = atan2(ojulian.y, ojulian.x)
					os = sin(oang)
					oc = cos(oang)
					ocrop = if orad > or_max || orad < or_min
									then if 1.0 == 1.0
											then vec2(0.0, 0.0)
											else vec2(oc, os) * (or_max)
									else ojulian

					blrad = osize * sqrt(unit_rnd_8)
					bangle = unit_rnd_9 * twopi()
					blur = vec2(cos(bangle), sin(bangle)) * blrad

					bir_min = min(misize, risize)
					bir_max = max(misize, risize)
					brad = length(blur)
					bang = atan2(blur.y, blur.x)
					bs = sin(bang)
					bc = cos(bang)
					bicrop = if brad > bir_max || brad < bir_min
										then if 1.0 == 1.0
													then vec2(0.0, 0.0)
													else vec2(bc, bs) * (bir_max)
										else blur

					bor_min = min(rosize, osize)
					bor_max = max(rosize, osize)
					bocrop = if brad > bor_max || brad < bor_min
										then if 1.0 == 1.0
													then vec2(0.0, 0.0)
													else vec2(bc, bs) * (bor_max)
										else blur

					rotm = mat2x2(cos(rot), -sin(rot),
												sin(rot), cos(rot))
					rlin = rotm * p_in * fsize

					z = complex(rlin.x, rlin.y)
					z1 = 1.0 / z
					result = invpi() * log((z + 1.0) / (-z + 1.0))
					arctanh = vec2(result.re, result.im)
					result2 = twoinvpi() * log(z + sqrt(z * z + 1.0))
					arcsinh = vec2(result2.re, result2.im)
					result3 = invpi() * log(z1 + sqrt(z1 + 1.0) * sqrt(z1 - 1.0))
					arcsech = lerp(vec2(result3.im, result3.re), vec2(-result3.im, -result3.re), if unit_rnd_6 <= 0.5
																																												then 0.0
																																												else 1.0)

					b = unit_rnd_2 * twopi()
					t = gauss_rnd_0 * fsize
					rgauss = vec2(cos(b), sin(b)) * t + (rlin / fsize)
					hemisphere = rgauss * (1.0 / sqrt(dot(rgauss, rgauss) + 1))

					inside = (if fswitch <= 0.0
										then arcsech
										else if fswitch <= 0.25
													then arctanh
													else if fswitch <= 0.5
																then arcsinh
																else if fswitch <= 0.75
																			then hemisphere
																			else rlin) * (risize)
					cA = max(-1.0, min(0.0, 1.0))
					xi = inside.x
					yi = inside.y
					frad = sqrt(xi * xi + yi * yi)
					fill = if frad > risize
									then if 1 == 1
												then vec2(0.0, 0.0)
												else
													let
														fang = atan2(yi, xi)
														frdc = (risize) + (unit_rnd_7 * 0.5 * cA)
														fs = sin(fang)
														fc = cos(fang)
													in
														vec2(frdc * fc, frdc * fs)
									else
										vec2(xi, yi)
				in
					lerp(lerp(icrop, ocrop, if unit_rnd_4 <= iw1 then 1.0 else 0.0), lerp(lerp(bicrop, bocrop, if unit_rnd_10 >= 0.5 then 1.0 else 0.0), fill, if unit_rnd_11 >= 0.5 then 1.0 else 0.0), if unit_rnd_5 <= iw2 then 1.0 else 0.0) * weight
			]]>
		</string>
	</transform_def>
</user_transforms>
