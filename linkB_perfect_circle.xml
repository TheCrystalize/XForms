<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkB_perfect_circle">
		<node name="input_params">
			<real name="perfect_circle">1</real>
			<real name="perfect_circle_ring" minval="0.0" maxval="1.0">0.1</real>
			<real name="perfect_circle_switch" minval="0.0" maxval="1.0">0.0</real>
			<real name="perfect_circle_mod">0.0</real>
			<real name="perfect_circle_inner_weight" minval="0.0" maxval="1.0">0.1</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="ring" />
			<real name="switch" />
			<real name="mod" />
			<real name="iw" />
		</node>

		<int name="num_unit_randoms">7</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkB_perfect_circle_init_result(perfect_circle, perfect_circle_ring, perfect_circle_switch, perfect_circle_mod, perfect_circle_inner_weight)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					rring = 1.0 - ring

					ga = unit_rnd_0 * twopi()
					gs = gauss_rnd_0 * mod
					gauss = vec2(cos(ga), sin(ga)) * gs + p_in
					hemisphere = gauss * (1.0 / sqrt(dot(gauss, gauss) + 1))

					sa = unit_rnd_2 * twopi()
					su = unit_rnd_3
					sr = if mod == 1
							then acos(su * 2 - 1)
							else acos(exp(log(1 - su) * mod) * 2 - 1)
					sm = sr * invpi()
					sineblur = vec2(cos(sa), sin(sa)) * sm

					rad = length(p_in)
					ang = atan2(p_in.y, p_in.x) + log(rad) * mod
					swirl = vec2(cos(ang), sin(ang)) * rad
					z = complex(swirl.x, swirl.y)
					z1 = 1.0 / z
					resulta = invpi() * log((z + 1.0) / (-z + 1.0))
					arctanh = vec2(resulta.re, resulta.im)
					resultb = twoinvpi() * log(z + sqrt(z * z + 1.0))
					arcsinh = vec2(resultb.re, resultb.im)
					resultc = invpi() * log(z + sqrt(z + 1.0) * sqrt(z - 1.0))
					arcsech = if unit_rnd_1 >= 0.5 then vec2(resultc.re, resultc.im) else vec2(-resultc.re, -resultc.im)
					rswitch = (if switch <= 0.0
										then swirl
										else if switch <= 0.2
													then hemisphere
													else if switch <= 0.4
																then sineblur
																else if switch <= 0.6
																			then arctanh
																			else if switch <= 0.8
																						then arcsinh
																						else arcsech) * rring

					imin = min(0.0, rring)
					imax = max(0.0, rring)
					irad = length(rswitch)
					iang = atan2(rswitch.y, rswitch.x)
					is = sin(iang)
					ic = cos(iang)
					inside = if irad > imax || irad < imin
									then if 1.0 == 1.0
												then vec2(0.0, 0.0)
												else vec2(ic, is) * (imax)
									else rswitch

					br = unit_rnd_4
					ba = unit_rnd_5 * twopi()
					blur = vec2(cos(ba), sin(ba)) * br
					bmin = min(rring, 1.0)
					bmax = max(rring, 1.0)
					rrad = length(blur)
					rang = atan2(blur.y, blur.x)
					rs = sin(rang)
					rc = cos(rang)
					ring = if rrad > bmax || rrad < bmin
									then if 1.0 == 1.0
												then vec2(0.0, 0.0)
												else vec2(rc, rs) * (bmax)
									else blur

					total = if unit_rnd_6 <= iw then ring else inside
				in
					total * weight
			]]>
		</string>
	</transform_def>
</user_transforms>
