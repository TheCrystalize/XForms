<?xml version="1.0" encoding="utf-8"?>
<user_transforms>
	<transform_def name="linkX_circle_plus_fill">
		<node name="input_params">
			<real name="circle_plus_fill">1</real>
			<real name="circle_plus_fill_zero" minval="0" maxval="1">0</real>
			<real name="circle_plus_fill_hemi_gaussian">1</real>
			<real name="circle_plus_fill_AT_rotate">1</real>
			<real name="circle_plus_fill_hemi_AT_switch" minval="0" maxval="1">0</real>
		</node>

		<node name="internal_params">
			<real name="weight" />
			<real name="zero" />
			<real name="g_power" />
			<real name="atr" />
			<real name="hatswitch" />
		</node>

		<int name="num_unit_randoms">3</int>
		<int name="num_gauss_randoms">1</int>

		<string name="winter_init_function">
			<![CDATA[
				linkX_circle_plus_fill_init_result(circle_plus_fill, circle_plus_fill_zero, circle_plus_fill_hemi_gaussian, circle_plus_fill_AT_rotate * quartpi(), circle_plus_fill_hemi_AT_switch)
			]]>
		</string>

		<string name="winter_eval_function">
			<![CDATA[
				let
					cri = 1.0
					cro = 10000000.0
					r_min = min(cri, cro)
					r_max = max(cri, cro)
					rad = length(p_in)
					ang = atan2(p_in.y, p_in.x)
					s = sin(ang)
					c = cos(ang)
					crop_out = if rad > cro || rad < cri
							then if zero == 0.0
								then vec2(0.0, 0.0)
								else vec2(c, s) * (cro * weight)
							else p_in * weight

					ur = unit_rnd_0 * twopi()
					gr = gauss_rnd_0 * g_power
					g = vec2(cos(ur), sin(ur)) * gr + p_in
					hemi = g * (weight / sqrt(dot(g, g) + 1))

					cri2 = 0.9
					cro2 = 1.0
					r_min2 = min(cri2, cro2)
					r_max2 = max(cri2, cro2)
					rad3 = length(hemi)
					ang2 = atan2(hemi.y, hemi.x)
					s3 = sin(ang2)
					c3 = cos(ang2)
					crop_out2 = if rad3 > cro2 || rad3 < cri2
							then if zero == 0.0
								then vec2(0.0, 0.0)
								else vec2(c3, s3) * (cro2 * weight)
							else hemi * weight


					rotm = mat2x2(cos(atr), -sin(atr),
							sin(atr), cos(atr))
					at_in = rotm * p_in
					z = complex(at_in.x, at_in.y)
					result = (weight * invpi()) * log((z + 1.0) / (-z + 1.0))
					cA = max(-1.0, min(0.0, 1.0))
					xi = result.re
					yi = result.im
					w2 = weight * 0.9
					rad2 = sqrt(xi * xi + yi * yi)
					at_out = lerp(if rad2 > 1 then if zero == 0 then vec2(0.0, 0.0)
							else let
								ang2 = atan2(yi, xi)
								rdc = 1 + (unit_rnd_0 * 0.5 * cA)
								s2 = sin(ang2)
								c2 = cos(ang2)
							in
								vec2(w2 * rdc * c2, w2 * rdc * s2)
							else vec2(w2 * xi, w2 * yi), crop_out2, if unit_rnd_2 >= 0.9
												then 1.0
												else 0.0)
				in
					lerp(crop_out, (if hatswitch == 0.0
								then at_out
								else hemi), if unit_rnd_1 >= 0.75
										then 1.0
										else 0.0)
			]]>
		</string>
	</transform_def>
</user_transforms>
